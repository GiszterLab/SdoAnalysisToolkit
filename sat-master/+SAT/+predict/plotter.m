%% predictSdo.plotter
% A header script containing collection of methods for plotting the
% SDO predictions; (Using the direct methods)
%
% Individual methods may be disabled/enabled by the user as is useful. 
%
% Code may be executed alone provided that 'predicted_px', 'observed_px',
% 'predicted_x' and 'observed_x' distributions and arrays are drawn. 
%
% Called by 'sdoAnalysis_demo.m' script

% Copyright (C) 2023  Trevor S. Smith
%  Drexel University College of Medicine
% 
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <https://www.gnu.org/licenses/>.

%% // Standalone Header 
if ~exist('INCLUDE_STATS', 'var')
    INCLUDE_STATS = 1; 
end
%else
    try
        SIG_PVAL = sdo(1).stats{1,1}.pVal; 
    catch
        SIG_PVAL = 0.05; 
    end
%end
if isstruct('sdo')
    N_BINS = length(sdo(1).levels)-1; 
else
    N_BINS = 20; 
end

if exist('xtData','var')
    XT_HZ = xtData{1,1}(1).fs; 
    binMS = 1000/XT_HZ; 
else
    binMS = 0.5; 
end

if ~isstruct('plotProp')
    try 
        fieldNames = fields(predicted_x); 
    catch
        fieldNames = fields(predicted_x{1,1}); 
    end
    plotProp = SAT.predict.assignPlotterProperties(fieldNames); 
end

if ~exist('SAVE_FIG', 'var')
    SAVE_FIG = 0; 
end

if ~exist('SAVE_FMT', 'var')
    SAVE_FMT = 'png'; 
end

if ~exist('SAVE_DIR', 'var')
    SAVE_DIR = ""; 
end

%// TARGETS for STA
if ~exist('XT_DC_CH_NO', 'var')
    disp("XT_DC_CH_NO not provided."); 
    XT_DC_CH_NO = 1; 
end
if ~exist('PP_DC_CH_NO', 'var')
    disp("PP_DC_CH_NO not provided."); 
    PP_DC_CH_NO = 1; 
end

N_SHUFFLES = 1000; %for bootstrap

STAT_TYPE = 'sum'; %['sum'/'mean'/'median'] %for statistics;

XT_DC_FIELDNAME = 'sensor'; 
%XT_DC_FIELDNAME = 'electrode'; %change this if using custom name fields; 
XT_DC_VARNAME = 'xtData'; %change this if using custom variable names; 


MAX_SPIKES_TO_DRAW = 50; 

%% Plotter Methods

%___ Allow earlier derivations of plotter to be commonly plotted here

%% Plot Hypothesized Transistion matrices, if present
if exist('normTMat', 'var')
    SAT.predict.plot.pxHH(normTMat, ...
    'saveFig',          SAVE_FIG,...
    'saveFormat',       SAVE_FMT,...
    'outputDirectory',  SAVE_DIR); 
end

%% PLOT METHODS:: SPIKE X SIGNAL

[~, ~, observed_at] = SAT.predict.predictPx(sdo, ...
    xtData, ppData, XT_DC_CH_NO, PP_DC_CH_NO); 

at0 = observed_at.t0_actual; 
at1 = observed_at.t1_actual;

nX0Pts = size(at0,1); 
nX1Pts = size(at1,1); 

%% FIX THIS! (Use new code)

xtDC = eval(XT_DC_VARNAME); 
[~, XT_SDO_CH_NO] = SAT.sdoUtils.match_DC_and_SDO_fields(xtDC, {sdo(:).signalType}, XT_DC_CH_NO, XT_DC_FIELDNAME); 

xt0 = discretize(at0, sdo(XT_SDO_CH_NO).levels); 
xt1 = discretize(at1, sdo(XT_SDO_CH_NO).levels); 

xs = xt0(end,:); 

%// post-spike STA
%plot_sta_v_x(at0, at1, [], ...
pxTools.plot.sta_v_x(at0, at1, [], ...
    'saveFig',          SAVE_FIG,...
    'saveFormat',       SAVE_FMT,...
    'outputDirectory',  SAVE_DIR,...
    'binMs', binMS); 

%plot_sta_v_x(at0, at1, ...
pxTools.plot.sta_v_x(at0, at1, ... 
    xs, ...
    'saveFig',          SAVE_FIG,...
    'saveFormat',       SAVE_FMT,...
    'outputDirectory',  SAVE_DIR,...
    'binMs', binMS); 

%plot_px_v_x_waterfall(...
pxTools.plot.px_v_x_waterfall( ... 
    observed_px.t0_actual, ...
    observed_px.t1_actual, ...
    xs, ...
    'saveFig',          SAVE_FIG,...
    'saveFormat',       SAVE_FMT,...
    'outputDirectory',  SAVE_DIR...       
    ); 

%plot_staPxt(xt0, xt1,...
pxTools.plot.staPxt(xt0, xt1, ... 
    N_BINS, ...
    1, ...
    'saveFig',          SAVE_FIG,...
    'saveFormat',       SAVE_FMT,...
    'outputDirectory',  SAVE_DIR,...
    'binMS', binMS); 

%plot_staPxt(xt0, xt1,...
pxTools.plot.staPxt(xt0, xt1, ... 
    N_BINS, ...
    0, ...
    'saveFig',          SAVE_FIG,...
    'saveFormat',       SAVE_FMT,...
    'outputDirectory',  SAVE_DIR,...
    'binMS', binMS); 

%% PLOT METHODS:: SPIKE X PREDICTED PX

sI = randi(length(observed_x.t1_actual), 1, MAX_SPIKES_TO_DRAW); 

sI = sort(sI); 

SAT.predict.plot.px_v_x(...
    predicted_px, ... 
    observed_x.t1_actual, ...
    'subIndex',         sI,...
    'saveFig',          SAVE_FIG,...
    'saveFormat',       SAVE_FMT,...
    'outputDirectory',  SAVE_DIR...    
    ); 

%% PLOT METHODS:: STATE X PREDICTED STATE

errorStruct = SAT.predict.calcPredictionError(...
    observed_x.t0_actual, ...
    observed_x.t1_actual,...
    predicted_x, ...
    observed_px.t1_actual, ...
    predicted_px, ...
    N_BINS,...
    'refName', 't1_actual', ...
    'nXtPts', nX1Pts); 

SAT.predict.plot.error_v_state(errorStruct, ...
    'saveFig',          SAVE_FIG,...
    'saveFormat',       SAVE_FMT,...
    'outputDirectory',  SAVE_DIR,...    
    'plotProp', plotProp); 

SAT.predict.plot.error_rates(errorStruct, ...
    'saveFig',          SAVE_FIG,...
    'saveFormat',       SAVE_FMT,...
    'outputDirectory',  SAVE_DIR,...
    'plotProp', plotProp); 

%// comparison cells for relative prediction error
compCell = {'SDO', 't0t1'; 'STA', 'SDO'}; 
SAT.predict.plot.relative_error_rates(...
    errorStruct, ...
    compCell, ...
    'saveFig',          SAVE_FIG,...
    'saveFormat',       SAVE_FMT,...
    'outputDirectory',  SAVE_DIR...    
    );  %varargin)

%% PLOT METHODS:: OBSERVED STATE X PREDICTED STATE
PXFIELD = 'KLD';
SAT.predict.plot.pxDistance(errorStruct,PXFIELD, ...
    N_SHUFFLES, ...
    'saveFig',          SAVE_FIG,...
    'saveFormat',       SAVE_FMT,...
    'outputDirectory',  SAVE_DIR,...    
    'plotProp', plotProp);

PXFIELD2 = 'logLikelihood'; 
SAT.predict.plot.pxDistance(errorStruct,PXFIELD2, ...
    N_SHUFFLES, ...
    'saveFig',          SAVE_FIG,...
    'saveFormat',       SAVE_FMT,...
    'outputDirectory',  SAVE_DIR,...    
    'plotProp', plotProp);

%% PLOT METHODS:: STATS TESTING
if INCLUDE_STATS 
   eFields = {'L0_running', 'L1_running', 'KLD', 'logLikelihood'}; 
   N_E_FIELDS = length(eFields);
   for f = 1:N_E_FIELDS
       SAT.predict.testSig(errorStruct, ...
        'pVal',             SIG_PVAL, ... 
        'nShuffles',        N_SHUFFLES, ... 
        'dataField',        eFields{f}, ...
        'statType',         STAT_TYPE, ...  
        'plotProp',         plotProp, ... 
        'saveFig',          SAVE_FIG, ... 
        'saveFormat',       SAVE_FMT, ... 
        'outputDirectory',  SAVE_DIR); 
   end
end


%% varspace cleanup
clear compCell N_SHUFFLES PXFIELD at0 at1 binMS INCLUDE_STATS MAX_SPIKES_TO_DRAW
clear N_BINS nX0Pts nX1Pts PLOT_ON PP_CH_NAME 
clear sI SIG_PVAL XT_CH_NAME  XT_HZ XT_SDO_CH_NO xtDataName
clear sfields PXFIELD2 eFields f N_E_FIELDS INCLUDE_STATS STAT_TYPE
%clear  SAVE_DIR SAVE_FIG SAVE_FMT
%clear observed_at observed_px observed_x plotProp predicted_px predicted_x
%clear PP_DC_CH_NO XT_DC_CH_NO
